/**
 * AtenMed - WhatsApp Business API Service
 * Servi√ßo de integra√ß√£o com WhatsApp Business API
 * Implementa bot conversacional para agendamento de consultas
 */

const axios = require('axios');
const logger = require('../utils/logger');
const Appointment = require('../models/Appointment');
const Doctor = require('../models/Doctor');
const Specialty = require('../models/Specialty');
const Clinic = require('../models/Clinic');
const Waitlist = require('../models/Waitlist');
const googleCalendarService = require('./googleCalendarService');
const aiService = require('./aiService');

// ===== CONFIGURA√á√ÉO =====
const WHATSAPP_API_URL = process.env.WHATSAPP_API_URL || 'https://graph.facebook.com/v18.0';
const WHATSAPP_PHONE_ID = process.env.WHATSAPP_PHONE_ID;
const WHATSAPP_TOKEN = process.env.WHATSAPP_TOKEN;
const WHATSAPP_VERIFY_TOKEN = process.env.WHATSAPP_VERIFY_TOKEN;

// Estado das conversas (em produ√ß√£o, usar Redis ou banco de dados)
const conversationState = new Map();

// ===== SESS√ÉO DE CONVERSA =====
class ConversationSession {
    constructor(phoneNumber) {
        this.phoneNumber = phoneNumber;
        this.state = 'initial';
        this.data = {};
        this.lastActivity = Date.now();
        this.conversationHistory = []; // Para IA
        this.useAI = aiService.shouldUseAI();
    }

    setState(state, data = {}) {
        this.state = state;
        this.data = { ...this.data, ...data };
        this.lastActivity = Date.now();
    }

    getData(key) {
        return this.data[key];
    }
    
    addToHistory(text, isUser = true) {
        this.conversationHistory.push({
            text,
            isUser,
            timestamp: Date.now()
        });
        
        // Manter apenas √∫ltimas 10 mensagens
        if (this.conversationHistory.length > 10) {
            this.conversationHistory = this.conversationHistory.slice(-10);
        }
    }

    reset() {
        this.state = 'initial';
        this.data = {};
        this.conversationHistory = [];
        this.lastActivity = Date.now();
    }

    isExpired(timeoutMinutes = 30) {
        return Date.now() - this.lastActivity > timeoutMinutes * 60 * 1000;
    }
}

// ===== INICIALIZA√á√ÉO =====
function initialize() {
    // Inicializar AI Service
    const aiEnabled = aiService.initialize();
    if (aiEnabled) {
        logger.info('ü§ñ WhatsApp com IA conversacional habilitada!');
    } else {
        logger.info('üì± WhatsApp sem IA (modo b√°sico)');
    }
    
    // Limpar sess√µes expiradas a cada 5 minutos
    setInterval(() => {
        for (const [phone, session] of conversationState.entries()) {
            if (session.isExpired()) {
                conversationState.delete(phone);
                logger.info(`Sess√£o expirada removida: ${phone}`);
            }
        }
    }, 5 * 60 * 1000);

    logger.info('üì± WhatsApp Business API Service inicializado');
}

// ===== WEBHOOK VERIFICATION =====
function verifyWebhook(mode, token, challenge) {
    if (!WHATSAPP_VERIFY_TOKEN) {
        logger.warn('‚ö†Ô∏è WHATSAPP_VERIFY_TOKEN n√£o configurado');
        return null;
    }
    if (mode === 'subscribe' && token === WHATSAPP_VERIFY_TOKEN) {
        logger.info('‚úÖ WhatsApp webhook verificado com sucesso');
        return challenge;
    }
    return null;
}

// ===== PROCESSAR MENSAGEM RECEBIDA =====
async function handleIncomingMessage(message) {
    try {
        const phoneNumber = message.from;
        const messageText = message.text?.body?.toLowerCase().trim();
        const messageType = message.type;

        if (!messageText || messageType !== 'text') {
            return;
        }

        logger.info(`üì© Mensagem recebida de ${phoneNumber}: ${messageText}`);

        // Obter ou criar sess√£o
        let session = conversationState.get(phoneNumber);
        if (!session) {
            session = new ConversationSession(phoneNumber);
            conversationState.set(phoneNumber, session);
        }

        // Processar comandos globais
        if (messageText === 'menu' || messageText === 'in√≠cio' || messageText === 'iniciar') {
            session.reset();
            await sendWelcomeMessage(phoneNumber);
            return;
        }

        if (messageText === 'cancelar') {
            session.reset();
            await sendMessage(phoneNumber, '‚ùå Opera√ß√£o cancelada. Digite *menu* para come√ßar novamente.');
            return;
        }

        // Adicionar mensagem ao hist√≥rico
        session.addToHistory(messageText, true);
        
        // Processar baseado no estado da conversa
        await processConversationFlow(phoneNumber, messageText, session);

    } catch (error) {
        logger.error('Erro ao processar mensagem:', error);
        await sendMessage(message.from, '‚ùå Desculpe, ocorreu um erro. Digite *menu* para tentar novamente.');
    }
}

// ===== FLUXO DE CONVERSA =====
async function processConversationFlow(phoneNumber, messageText, session) {
    switch (session.state) {
        case 'initial':
            await sendWelcomeMessage(phoneNumber);
            session.setState('awaiting_action');
            break;

        case 'awaiting_action':
            await handleActionSelection(phoneNumber, messageText, session);
            break;

        case 'awaiting_clinic':
            await handleClinicSelection(phoneNumber, messageText, session);
            break;

        case 'awaiting_specialty':
            await handleSpecialtySelection(phoneNumber, messageText, session);
            break;

        case 'awaiting_doctor':
            await handleDoctorSelection(phoneNumber, messageText, session);
            break;

        case 'awaiting_date':
            await handleDateSelection(phoneNumber, messageText, session);
            break;

        case 'awaiting_time':
            await handleTimeSelection(phoneNumber, messageText, session);
            break;

        case 'awaiting_patient_name':
            await handlePatientName(phoneNumber, messageText, session);
            break;

        case 'awaiting_confirmation':
            await handleFinalConfirmation(phoneNumber, messageText, session);
            break;

        case 'awaiting_appointment_id':
            await handleAppointmentCheck(phoneNumber, messageText, session);
            break;

        default:
            await sendWelcomeMessage(phoneNumber);
            session.setState('awaiting_action');
    }
}

// ===== MENSAGEM DE BOAS-VINDAS =====
async function sendWelcomeMessage(phoneNumber) {
    const hour = new Date().getHours();
    let greeting;
    
    if (hour < 12) {
        greeting = 'Bom dia! ‚òÄÔ∏è';
    } else if (hour < 18) {
        greeting = 'Boa tarde! üòä';
    } else {
        greeting = 'Boa noite! üåô';
    }

    // Variar sauda√ß√µes para parecer mais humano
    const welcomes = [
        `${greeting} Tudo bem? Aqui √© da *AtenMed*!`,
        `${greeting} Como vai? Sou da equipe *AtenMed*!`,
        `${greeting} Prazer em falar com voc√™! Aqui √© da *AtenMed*!`
    ];
    
    const randomWelcome = welcomes[Math.floor(Math.random() * welcomes.length)];
    
    const message = `${randomWelcome}

Em que posso te ajudar hoje? üòä

1Ô∏è‚É£ Quero marcar uma consulta
2Ô∏è‚É£ Ver minhas consultas agendadas
3Ô∏è‚É£ Preciso cancelar uma consulta
4Ô∏è‚É£ Entrar na lista de espera
5Ô∏è‚É£ Falar com algu√©m da equipe

√â s√≥ digitar o n√∫mero da op√ß√£o!`;

    await sendMessage(phoneNumber, message);
}

// ===== SELE√á√ÉO DE A√á√ÉO =====
async function handleActionSelection(phoneNumber, messageText, session) {
    // Se IA estiver habilitada, analisar inten√ß√£o
    let action = messageText;
    
    if (session.useAI && isNaN(messageText)) {
        const intent = await aiService.analyzeIntent(messageText);
        
        // Mapear inten√ß√£o para a√ß√£o
        if (intent === 'agendar') action = '1';
        else if (intent === 'consultar') action = '2';
        else if (intent === 'cancelar') action = '3';
        else if (intent === 'ajuda') action = '5';
        else if (intent === 'confirmar') action = '1'; // Assume que quer agendar
    }
    
    switch (action) {
        case '1':
            session.setState('awaiting_clinic');
            await sendTypingIndicator(phoneNumber);
            await sendClinicOptions(phoneNumber);
            break;

        case '2':
            session.setState('awaiting_appointment_id');
            const consultMessages = [
                'Claro! Vou verificar suas consultas aqui... üîç\n\nPode me passar seu telefone ou o c√≥digo da consulta?',
                'Perfeito! Deixa eu dar uma olhada nas suas consultas... üìã\n\nQual seu telefone ou c√≥digo do agendamento?',
                'Certo! Vou buscar suas consultas aqui... ‚ú®\n\nMe passa seu telefone ou o c√≥digo?'
            ];
            await sendMessage(phoneNumber, consultMessages[Math.floor(Math.random() * consultMessages.length)]);
            break;

        case '3':
            session.setState('awaiting_appointment_id');
            session.data.cancelMode = true;
            const cancelMessages = [
                'Entendi... vou te ajudar com isso! üòî\n\nQual o c√≥digo da consulta que voc√™ quer cancelar?',
                'Sem problemas! Acontece... ü§ù\n\nMe passa o c√≥digo da consulta pra eu cancelar pra voc√™?',
                'Tudo bem! Vou cancelar pra voc√™... üëå\n\nQual o c√≥digo da consulta?'
            ];
            await sendMessage(phoneNumber, cancelMessages[Math.floor(Math.random() * cancelMessages.length)]);
            break;

        case '4':
            session.setState('awaiting_clinic');
            session.data.waitlistMode = true;
            await sendMessage(phoneNumber, 'Boa! Vou te colocar na lista de espera... üìù\n\nVamos come√ßar:');
            await sendTypingIndicator(phoneNumber);
            await sendClinicOptions(phoneNumber);
            break;

        case '5':
            const transferMessages = [
                'üë§ Tudo bem! Vou chamar algu√©m da equipe pra falar com voc√™...\n\nS√≥ um momentinho! ‚è±Ô∏è',
                'üë§ Claro! Deixa eu transferir voc√™ pra um colega meu...\n\nJ√° volto! üòä',
                'üë§ Combinado! Vou te passar pra algu√©m da equipe agora...\n\nAguarda s√≥ um pouquinho! ‚ú®'
            ];
            await sendMessage(phoneNumber, transferMessages[Math.floor(Math.random() * transferMessages.length)]);
            session.reset();
            break;

        default:
            // Se IA est√° habilitada, tentar gerar resposta contextual
            if (session.useAI) {
                const aiResponse = await aiService.processMessage(
                    messageText,
                    session.conversationHistory
                );
                
                if (aiResponse) {
                    await sendMessage(phoneNumber, aiResponse);
                    session.addToHistory(aiResponse, false);
                    
                    // Reenviar menu ap√≥s resposta da IA
                    await sendTypingIndicator(phoneNumber, 1000);
                    await sendWelcomeMessage(phoneNumber);
                    return;
                }
            }
            
            const errorMessages = [
                'Ops! N√£o entendi direito... üòÖ\n\nPode escolher uma op√ß√£o de 1 a 5?',
                'Hmm... essa op√ß√£o n√£o t√° aqui n√£o... ü§î\n\nTenta de novo? Digite um n√∫mero de 1 a 5!',
                'Eita! N√£o achei essa op√ß√£o... üò¨\n\nEscolhe uma de 1 a 5, por favor!'
            ];
            await sendMessage(phoneNumber, errorMessages[Math.floor(Math.random() * errorMessages.length)]);
    }
}

// ===== SIMULAR "DIGITANDO..." =====
async function sendTypingIndicator(phoneNumber, delayMs = 1500) {
    // Simula tempo de digita√ß√£o para parecer mais humano
    await new Promise(resolve => setTimeout(resolve, delayMs));
}

// ===== ENVIAR OP√á√ïES DE CL√çNICA =====
async function sendClinicOptions(phoneNumber) {
    try {
        const clinics = await Clinic.find({ isActive: true }).select('name address');

        if (clinics.length === 0) {
            await sendMessage(phoneNumber, 'Puts... no momento n√£o temos cl√≠nicas dispon√≠veis. üòî\n\nTenta de novo mais tarde?');
            return;
        }

        const introMessages = [
            'Legal! Vamos l√° ent√£o... üòä\n\nOnde voc√™ prefere ser atendido?',
            'Perfeito! Primeiro passo... üè•\n\nQual cl√≠nica fica melhor pra voc√™?',
            '√ìtimo! Vamos marcar ent√£o... ‚ú®\n\nEm qual cl√≠nica voc√™ quer consultar?'
        ];

        let message = introMessages[Math.floor(Math.random() * introMessages.length)] + '\n\n';
        
        clinics.forEach((clinic, index) => {
            message += `${index + 1}Ô∏è‚É£ *${clinic.name}*\n`;
            if (clinic.address) {
                message += `   üìç ${clinic.address}\n`;
            }
            message += '\n';
        });

        message += 'Qual voc√™ escolhe? √â s√≥ digitar o n√∫mero!';

        await sendMessage(phoneNumber, message);
    } catch (error) {
        logger.error('Erro ao buscar cl√≠nicas:', error);
        const errorMessages = [
            'Ai, deu um probleminha aqui... üòÖ\n\nTenta de novo pra mim?',
            'Ops! Algo deu errado... ü§î\n\nVamos tentar mais uma vez?',
            'Eita! Sistema travou aqui... üò¨\n\nTenta novamente, por favor!'
        ];
        await sendMessage(phoneNumber, errorMessages[Math.floor(Math.random() * errorMessages.length)]);
    }
}

// ===== SELE√á√ÉO DE CL√çNICA =====
async function handleClinicSelection(phoneNumber, messageText, session) {
    try {
        const clinicIndex = parseInt(messageText) - 1;
        const clinics = await Clinic.find({ isActive: true });

        if (clinicIndex < 0 || clinicIndex >= clinics.length) {
            const errorMessages = [
                'Hmm... esse n√∫mero n√£o t√° aqui n√£o... ü§î\n\nTenta escolher um dos que aparecem na lista?',
                'Opa! N√£o achei essa op√ß√£o... üòÖ\n\nEscolhe um n√∫mero da lista, por favor!',
                'Puts! N√∫mero inv√°lido... üò¨\n\nVamos tentar de novo? Digite um n√∫mero que apare√ßa a√≠!'
            ];
            await sendMessage(phoneNumber, errorMessages[Math.floor(Math.random() * errorMessages.length)]);
            return;
        }

        const clinic = clinics[clinicIndex];
        session.setState('awaiting_specialty', { clinicId: clinic._id, clinicName: clinic.name });

        const confirmMessages = [
            `Show! ${clinic.name} escolhida! üëç`,
            `Boa escolha! ${clinic.name}! ‚ú®`,
            `Perfeito! Vamos marcar na ${clinic.name} ent√£o! üòä`
        ];
        
        await sendMessage(phoneNumber, confirmMessages[Math.floor(Math.random() * confirmMessages.length)]);
        await sendTypingIndicator(phoneNumber, 1000);
        await sendSpecialtyOptions(phoneNumber, clinic._id);
    } catch (error) {
        logger.error('Erro ao processar cl√≠nica:', error);
        await sendMessage(phoneNumber, 'Ops! Deu um errinho aqui... üòÖ\n\nVamos tentar de novo?');
    }
}

// ===== ENVIAR OP√á√ïES DE ESPECIALIDADE =====
async function sendSpecialtyOptions(phoneNumber, clinicId) {
    try {
        const specialties = await Specialty.find({ clinic: clinicId }).select('name description');

        if (specialties.length === 0) {
            await sendMessage(phoneNumber, 'Putz... essa cl√≠nica t√° sem especialidades no momento. üòï\n\nQuer tentar outra?');
            return;
        }

        const introMessages = [
            'Agora me diz... qual especialidade voc√™ precisa? ü©∫',
            'Certo! E pra qual especialidade voc√™ quer marcar? üë®‚Äç‚öïÔ∏è',
            'Beleza! Agora escolhe a √°rea... qual especialidade? üíâ'
        ];

        let message = introMessages[Math.floor(Math.random() * introMessages.length)] + '\n\n';
        
        specialties.forEach((specialty, index) => {
            message += `${index + 1}Ô∏è‚É£ *${specialty.name}*\n`;
            if (specialty.description) {
                message += `   ${specialty.description}\n`;
            }
            message += '\n';
        });

        message += 'Qual delas? üòä';

        await sendMessage(phoneNumber, message);
    } catch (error) {
        logger.error('Erro ao buscar especialidades:', error);
        await sendMessage(phoneNumber, 'Eita! Travou aqui... üòÖ\n\nTenta de novo pra mim?');
    }
}

// ===== SELE√á√ÉO DE ESPECIALIDADE =====
async function handleSpecialtySelection(phoneNumber, messageText, session) {
    try {
        const specialtyIndex = parseInt(messageText) - 1;
        const specialties = await Specialty.find({ clinic: session.getData('clinicId') });

        if (specialtyIndex < 0 || specialtyIndex >= specialties.length) {
            await sendMessage(phoneNumber, '‚ùì N√∫mero inv√°lido. Por favor, escolha uma op√ß√£o v√°lida.');
            return;
        }

        const specialty = specialties[specialtyIndex];
        session.setState('awaiting_doctor', { 
            specialtyId: specialty._id, 
            specialtyName: specialty.name 
        });

        await sendDoctorOptions(phoneNumber, specialty._id);
    } catch (error) {
        logger.error('Erro ao processar especialidade:', error);
        await sendMessage(phoneNumber, '‚ùå Erro ao processar. Tente novamente.');
    }
}

// ===== ENVIAR OP√á√ïES DE M√âDICO =====
async function sendDoctorOptions(phoneNumber, specialtyId) {
    try {
        const doctors = await Doctor.find({ 
            specialties: specialtyId, 
            isActive: true 
        }).select('name');

        if (doctors.length === 0) {
            await sendMessage(phoneNumber, '‚ùå Nenhum m√©dico dispon√≠vel para esta especialidade.');
            return;
        }

        let message = 'üë®‚Äç‚öïÔ∏è *Escolha o m√©dico:*\n\n';
        doctors.forEach((doctor, index) => {
            message += `${index + 1}Ô∏è‚É£ ${doctor.name}\n`;
        });
        message += '\n0Ô∏è‚É£ Qualquer m√©dico dispon√≠vel';

        await sendMessage(phoneNumber, message);
    } catch (error) {
        logger.error('Erro ao buscar m√©dicos:', error);
        await sendMessage(phoneNumber, '‚ùå Erro ao buscar m√©dicos. Tente novamente.');
    }
}

// ===== SELE√á√ÉO DE M√âDICO =====
async function handleDoctorSelection(phoneNumber, messageText, session) {
    try {
        const doctors = await Doctor.find({ 
            specialties: session.getData('specialtyId'), 
            isActive: true 
        });

        let doctor;
        if (messageText === '0') {
            doctor = doctors[0];
            const anyDoctorMessages = [
                `Legal! Ent√£o vou buscar o primeiro dispon√≠vel pra voc√™... üëå`,
                `Boa! Deixa comigo, vou achar o melhor hor√°rio dispon√≠vel! ‚ú®`,
                `Tranquilo! Vou ver quem t√° dispon√≠vel pra te atender! üòä`
            ];
            await sendMessage(phoneNumber, anyDoctorMessages[Math.floor(Math.random() * anyDoctorMessages.length)]);
        } else {
            const doctorIndex = parseInt(messageText) - 1;
            if (doctorIndex < 0 || doctorIndex >= doctors.length) {
                await sendMessage(phoneNumber, 'Hmm... n√£o achei esse n√∫mero aqui... üòÖ\n\nEscolhe um da lista, por favor!');
                return;
            }
            doctor = doctors[doctorIndex];
            const confirmDoctorMessages = [
                `Perfeito! Vou marcar com ${doctor.name}! üë®‚Äç‚öïÔ∏è`,
                `√ìtima escolha! ${doctor.name} √© muito bom(a)! ‚ú®`,
                `Show! Marcando com ${doctor.name} ent√£o! üòä`
            ];
            await sendMessage(phoneNumber, confirmDoctorMessages[Math.floor(Math.random() * confirmDoctorMessages.length)]);
        }

        session.setState('awaiting_date', { 
            doctorId: doctor._id, 
            doctorName: doctor.name,
            calendarId: doctor.googleCalendarId
        });

        await sendTypingIndicator(phoneNumber, 1000);
        
        const dateMessages = [
            `üìÖ Agora me fala... que dia voc√™ quer vir?\n\nDigita no formato: *DD/MM/AAAA*\nPor exemplo: 25/12/2024`,
            `üìÖ Beleza! E qual dia fica melhor pra voc√™?\n\nManda assim: *DD/MM/AAAA*\nExemplo: 25/12/2024`,
            `üìÖ Certo! Qual a data que voc√™ prefere?\n\nEscreve assim: *DD/MM/AAAA*\nTipo: 25/12/2024`
        ];
        
        await sendMessage(phoneNumber, dateMessages[Math.floor(Math.random() * dateMessages.length)]);
    } catch (error) {
        logger.error('Erro ao processar m√©dico:', error);
        await sendMessage(phoneNumber, 'Ops! Algo deu errado... üò¨\n\nTenta de novo pra mim?');
    }
}

// ===== SELE√á√ÉO DE DATA =====
async function handleDateSelection(phoneNumber, messageText, session) {
    try {
        // Validar formato de data
        const dateRegex = /^(\d{2})\/(\d{2})\/(\d{4})$/;
        const match = messageText.match(dateRegex);

        if (!match) {
            const formatErrorMessages = [
                'Ops! N√£o entendi essa data... ü§î\n\nTenta assim: *DD/MM/AAAA*\nPor exemplo: 25/12/2024',
                'Hmm... formato errado... üòÖ\n\nDigita assim: *DD/MM/AAAA*\nTipo: 25/12/2024',
                'Eita! Essa data t√° estranha... üò¨\n\nManda no formato: *DD/MM/AAAA*\nExemplo: 25/12/2024'
            ];
            await sendMessage(phoneNumber, formatErrorMessages[Math.floor(Math.random() * formatErrorMessages.length)]);
            return;
        }

        const [, day, month, year] = match;
        const date = new Date(year, month - 1, day);

        // Validar se a data √© futura
        if (date < new Date()) {
            const pastDateMessages = [
                'Puts... essa data j√° passou! üòÖ\n\nEscolhe uma data futura, por favor!',
                'Opa! N√£o d√° pra marcar no passado... ü§î\n\nManda uma data que ainda vai chegar!',
                'Eita! Essa j√° foi embora... üò¨\n\nPrecisa ser uma data futura!'
            ];
            await sendMessage(phoneNumber, pastDateMessages[Math.floor(Math.random() * pastDateMessages.length)]);
            return;
        }

        session.setState('awaiting_time', { selectedDate: date });

        const checkingMessages = [
            `Legal! Deixa eu ver os hor√°rios dispon√≠veis pra ${date.toLocaleDateString('pt-BR')}... üîç`,
            `Boa! Vou olhar a agenda de ${date.toLocaleDateString('pt-BR')} aqui... ‚è∞`,
            `Show! Conferindo os hor√°rios de ${date.toLocaleDateString('pt-BR')}... üìã`
        ];
        
        await sendMessage(phoneNumber, checkingMessages[Math.floor(Math.random() * checkingMessages.length)]);
        await sendTypingIndicator(phoneNumber, 2000);
        
        // Buscar hor√°rios dispon√≠veis
        await sendAvailableTimeSlots(phoneNumber, session);
    } catch (error) {
        logger.error('Erro ao processar data:', error);
        await sendMessage(phoneNumber, 'Ops! Deu pau aqui... üòÖ\n\nTenta digitar a data de novo?');
    }
}

// ===== ENVIAR HOR√ÅRIOS DISPON√çVEIS =====
async function sendAvailableTimeSlots(phoneNumber, session) {
    try {
        const calendarId = session.getData('calendarId');
        const selectedDate = session.getData('selectedDate');

        // Normalizar data para YYYY-MM-DD
        const dateStr = (selectedDate instanceof Date)
            ? selectedDate.toISOString().slice(0, 10)
            : selectedDate;

        // Buscar slots dispon√≠veis via Google Calendar
        const availableSlots = await googleCalendarService.getAvailableSlots(
            calendarId,
            dateStr,
            { slotDuration: 30 }
        );

        if (availableSlots.length === 0) {
            const noSlotsMessages = [
                `Puts... nesse dia t√° lotado! üòï\n\nTenta outra data? Digita no formato *DD/MM/AAAA*`,
                `Ah n√£o! N√£o achei nenhum hor√°rio livre nesse dia... üòî\n\nQue tal tentar outro dia? *DD/MM/AAAA*`,
                `Eita! T√° tudo ocupado nessa data... üò¨\n\nEscolhe outro dia? Manda no formato *DD/MM/AAAA*`
            ];
            await sendMessage(phoneNumber, noSlotsMessages[Math.floor(Math.random() * noSlotsMessages.length)]);
            session.setState('awaiting_date');
            return;
        }

        const slotsMessages = [
            `Olha s√≥! Achei esses hor√°rios vagos pra ${selectedDate.toLocaleDateString('pt-BR')}:`,
            `Legal! Tem essas op√ß√µes dispon√≠veis em ${selectedDate.toLocaleDateString('pt-BR')}:`,
            `Boa! Essas s√£o as vagas livres pra ${selectedDate.toLocaleDateString('pt-BR')}:`
        ];

        let message = slotsMessages[Math.floor(Math.random() * slotsMessages.length)] + '\n\nüïê ';
        availableSlots.slice(0, 10).forEach((slot, index) => {
            message += `${index + 1}Ô∏è‚É£ ${slot}\n`;
        });

        message += '\nQual hor√°rio fica melhor pra voc√™? üòä';

        await sendMessage(phoneNumber, message);
    } catch (error) {
        logger.error('Erro ao buscar hor√°rios:', error);
        const errorMessages = [
            'Ai... deu um problema pra buscar os hor√°rios... üòÖ\n\nDigita a data de novo pra mim?',
            'Ops! Sistema travou aqui... üò¨\n\nTenta mandar a data novamente?',
            'Eita! N√£o consegui verificar... ü§î\n\nManda a data de novo? *DD/MM/AAAA*'
        ];
        await sendMessage(phoneNumber, errorMessages[Math.floor(Math.random() * errorMessages.length)]);
        session.setState('awaiting_date');
    }
}

// ===== SELE√á√ÉO DE HOR√ÅRIO =====
async function handleTimeSelection(phoneNumber, messageText, session) {
    try {
        const calendarId = session.getData('calendarId');
        const selectedDate = session.getData('selectedDate');

        // Normalizar data para YYYY-MM-DD
        const dateStr = (selectedDate instanceof Date)
            ? selectedDate.toISOString().slice(0, 10)
            : selectedDate;

        const availableSlots = await googleCalendarService.getAvailableSlots(
            calendarId,
            dateStr,
            { slotDuration: 30 }
        );

        const timeIndex = parseInt(messageText) - 1;
        if (timeIndex < 0 || timeIndex >= availableSlots.length) {
            await sendMessage(phoneNumber, '‚ùì N√∫mero inv√°lido. Por favor, escolha uma op√ß√£o v√°lida.');
            return;
        }

        const selectedTime = availableSlots[timeIndex];
        session.setState('awaiting_patient_name', { selectedTime });

        await sendMessage(phoneNumber, 'üë§ Por favor, informe o *nome completo* do paciente:');
    } catch (error) {
        logger.error('Erro ao processar hor√°rio:', error);
        await sendMessage(phoneNumber, '‚ùå Erro ao processar. Tente novamente.');
    }
}

// ===== NOME DO PACIENTE =====
async function handlePatientName(phoneNumber, messageText, session) {
    if (messageText.length < 3) {
        const shortNameMessages = [
            'Hmm... esse nome t√° muito curtinho... ü§î\n\nManda o nome completo pra mim?',
            'Ops! Preciso do nome completo, por favor! üòä',
            'Puts... nome muito pequeno... üòÖ\n\nDigita o nome todo?'
        ];
        await sendMessage(phoneNumber, shortNameMessages[Math.floor(Math.random() * shortNameMessages.length)]);
        return;
    }

    session.setState('awaiting_confirmation', { patientName: messageText });

    const preparingMessages = [
        'Perfeito! Deixa eu montar o resumo aqui pra voc√™ conferir... üìù',
        'Show! Vou organizar tudo certinho pra voc√™ ver... ‚ú®',
        'Legal! Montando o resumo da consulta... üìã'
    ];
    
    await sendMessage(phoneNumber, preparingMessages[Math.floor(Math.random() * preparingMessages.length)]);
    await sendTypingIndicator(phoneNumber, 1500);

    // Resumo do agendamento
    const summaryIntros = [
        '‚ú® *Olha s√≥ como ficou:*',
        'üìã *Confere a√≠ pra mim:*',
        'üëÄ *T√° tudo certo? D√° uma olhada:*'
    ];

    const summary = `${summaryIntros[Math.floor(Math.random() * summaryIntros.length)]}

üë§ *Paciente:* ${session.getData('patientName')}
üìû *Telefone:* ${phoneNumber}
üè• *Cl√≠nica:* ${session.getData('clinicName')}
ü©∫ *Especialidade:* ${session.getData('specialtyName')}
üë®‚Äç‚öïÔ∏è *M√©dico(a):* ${session.getData('doctorName')}
üìÖ *Data:* ${session.getData('selectedDate').toLocaleDateString('pt-BR')}
üïê *Hor√°rio:* ${session.getData('selectedTime')}

T√° tudo certo? Posso confirmar? ü§î

1Ô∏è‚É£ *Sim! Confirma a√≠* ‚úÖ
2Ô∏è‚É£ *N√£o, quero mudar algo* ‚ùå`;

    await sendMessage(phoneNumber, summary);
}

// ===== CONFIRMA√á√ÉO FINAL =====
async function handleFinalConfirmation(phoneNumber, messageText, session) {
    if (messageText === '1') {
        const confirmingMessages = [
            'Eba! Bora marcar ent√£o! üéâ\n\nS√≥ um instantinho...',
            'Show! Vou confirmar aqui pra voc√™! ‚ú®\n\nAguarda s√≥ um pouquinho...',
            'Perfeito! J√° t√¥ finalizando aqui! üòä\n\nS√≥ mais um segundo...'
        ];
        await sendMessage(phoneNumber, confirmingMessages[Math.floor(Math.random() * confirmingMessages.length)]);
        await sendTypingIndicator(phoneNumber, 2000);
        await createAppointment(phoneNumber, session);
    } else if (messageText === '2') {
        session.reset();
        const cancelMessages = [
            'Tudo bem! Cancelei aqui... üëå\n\nQuando quiser marcar de novo √© s√≥ digitar *menu*, beleza?',
            'Sem problemas! N√£o vou confirmar... üòä\n\nPra tentar de novo depois, digita *menu*!',
            'Tranquilo! Cancelado ent√£o... üëç\n\nQuando decidir, manda *menu* que a gente marca!'
        ];
        await sendMessage(phoneNumber, cancelMessages[Math.floor(Math.random() * cancelMessages.length)]);
    } else {
        const errorMessages = [
            'Hmm... n√£o entendi... üòÖ\n\nDigita *1* pra confirmar ou *2* pra cancelar!',
            'Ops! Op√ß√£o errada... ü§î\n\n*1* = Confirma | *2* = Cancela',
            'Eita! Escolhe *1* ou *2*, por favor! üòä'
        ];
        await sendMessage(phoneNumber, errorMessages[Math.floor(Math.random() * errorMessages.length)]);
    }
}

// ===== CRIAR AGENDAMENTO =====
async function createAppointment(phoneNumber, session) {
    try {
        const selectedDate = session.getData('selectedDate');
        const selectedTime = session.getData('selectedTime');

        // Criar data/hora completa
        const [hours, minutes] = selectedTime.split(':');
        const startTime = new Date(selectedDate);
        startTime.setHours(parseInt(hours), parseInt(minutes), 0, 0);

        const endTime = new Date(startTime);
        endTime.setMinutes(endTime.getMinutes() + 30);

        // Criar agendamento no banco
        const appointment = await Appointment.create({
            patient: {
                name: session.getData('patientName'),
                phone: phoneNumber
            },
            doctor: session.getData('doctorId'),
            specialty: session.getData('specialtyId'),
            clinic: session.getData('clinicId'),
            scheduledDate: selectedDate,
            scheduledTime: selectedTime,
            status: 'confirmado',
            source: 'whatsapp',
            confirmations: {
                patient: {
                    confirmed: true,
                    confirmedAt: new Date(),
                    method: 'whatsapp'
                }
            }
        });

        // Criar evento no Google Calendar
        await googleCalendarService.createCalendarEvent(session.getData('calendarId'), {
            summary: `Consulta - ${session.getData('patientName')}`,
            description: `Paciente: ${session.getData('patientName')}\nTelefone: ${phoneNumber}\nEspecialidade: ${session.getData('specialtyName')}`,
            startTime,
            endTime,
            attendees: []
        });

        const successIntros = [
            'üéâ *Tudo certo! Consulta marcada com sucesso!*',
            '‚úÖ *Pronto! Sua consulta t√° confirmada!*',
            'üéä *Eba! Consegui marcar pra voc√™!*'
        ];

        const closingMessages = [
            'Vou te mandar lembretes 24h e 1h antes da consulta, combinado? üîî\n\nSe precisar cancelar ou mudar alguma coisa, √© s√≥ digitar *menu*!\n\nNos vemos l√°! At√© breve! üëãüòä',
            'Ah! Vou te lembrar um dia antes e 1h antes da consulta, t√°? üòâ\n\nQualquer coisa, digita *menu* que te ajudo!\n\nTe vejo na consulta! At√©! üåü',
            'N√£o esquece! Vou te avisar 24h e 1h antes, beleza? üì≤\n\nPra cancelar ou reagendar, manda *menu*!\n\nAt√© mais! Cuida-se! üíö'
        ];

        await sendMessage(phoneNumber, `${successIntros[Math.floor(Math.random() * successIntros.length)]}

üé´ *C√≥digo da consulta:* ${appointment._id.toString().slice(-6).toUpperCase()}

üìÖ *Quando:* ${startTime.toLocaleDateString('pt-BR')} √†s ${selectedTime}
üè• *Onde:* ${session.getData('clinicName')}
üë®‚Äç‚öïÔ∏è *Com quem:* ${session.getData('doctorName')}

${closingMessages[Math.floor(Math.random() * closingMessages.length)]}`);


        session.reset();
    } catch (error) {
        logger.error('Erro ao criar agendamento:', error);
        const errorMessages = [
            'Ai n√£o! Deu um erro na hora de confirmar... üòî\n\nTenta de novo digitando *menu* ou me chama que te ajudo!',
            'Puts... algo deu errado aqui... üò¨\n\nDesculpa! Tenta mais uma vez? Digita *menu*!',
            'Eita! Sistema travou na confirma√ß√£o... üòÖ\n\nVamos tentar de novo? Manda *menu*!'
        ];
        await sendMessage(phoneNumber, errorMessages[Math.floor(Math.random() * errorMessages.length)]);
        session.reset();
    }
}

// ===== CONSULTAR AGENDAMENTO =====
async function handleAppointmentCheck(phoneNumber, messageText, session) {
    try {
        const searchingMessages = [
            'Deixa eu procurar aqui pra voc√™... üîç',
            'Opa! Vou dar uma olhada nas suas consultas... üìã',
            'S√≥ um instante! Buscando suas consultas... ‚è≥'
        ];
        
        await sendMessage(phoneNumber, searchingMessages[Math.floor(Math.random() * searchingMessages.length)]);
        await sendTypingIndicator(phoneNumber, 1500);
        
        const appointments = await Appointment.find({
            $or: [
                { 'patient.phone': phoneNumber },
                { _id: messageText }
            ],
            scheduledDate: { $gte: new Date() },
            status: { $in: ['confirmado', 'pendente'] }
        })
        .populate('doctor', 'name')
        .populate('specialty', 'name')
        .populate('clinic', 'name')
        .sort({ scheduledDate: 1, scheduledTime: 1 });

        if (appointments.length === 0) {
            const notFoundMessages = [
                'Hmm... n√£o achei nenhuma consulta marcada no seu nome... ü§î\n\nQuer marcar uma? Digita *menu*!',
                'Puts... n√£o encontrei agendamento pra voc√™... üòï\n\nVamos marcar uma consulta? Manda *menu*!',
                'Eita! N√£o vi nada agendado aqui... üò¨\n\nQuer agendar agora? √â s√≥ digitar *menu*!'
            ];
            await sendMessage(phoneNumber, notFoundMessages[Math.floor(Math.random() * notFoundMessages.length)]);
            session.reset();
            return;
        }

        const foundMessages = [
            appointments.length === 1 ? 'Achei! Voc√™ tem 1 consulta marcada:' : `Legal! Encontrei ${appointments.length} consultas suas:`,
            appointments.length === 1 ? 'Olha s√≥! Tem uma consulta agendada:' : `Opa! Vi que tem ${appointments.length} consultas marcadas:`,
            appointments.length === 1 ? 'Boa! Aqui t√° sua consulta:' : `Show! Essas s√£o suas ${appointments.length} consultas:`
        ];

        let message = `üìã *${foundMessages[Math.floor(Math.random() * foundMessages.length)]}*\n\n`;
        
        appointments.forEach((appt, index) => {
            message += `${index + 1}Ô∏è‚É£ *C√≥digo:* ${appt._id.toString().slice(-6).toUpperCase()}\n`;
            message += `   üìÖ ${new Date(appt.scheduledDate).toLocaleDateString('pt-BR')} √†s ${appt.scheduledTime}\n`;
            message += `   üë®‚Äç‚öïÔ∏è ${appt.doctor.name}\n`;
            message += `   ü©∫ ${appt.specialty.name}\n`;
            message += `   üìç ${appt.clinic.name}\n\n`;
        });

        message += '\nPrecisa de mais alguma coisa? Digita *menu*! üòä';

        await sendMessage(phoneNumber, message);
        session.reset();
    } catch (error) {
        logger.error('Erro ao buscar agendamento:', error);
        const errorMessages = [
            'Ops! Deu um erro ao buscar... üòÖ\n\nTenta de novo? Digita *menu*!',
            'Ai... sistema travou aqui... üò¨\n\nVamos tentar novamente? Manda *menu*!',
            'Eita! N√£o consegui buscar... ü§î\n\nTenta mais uma vez? *menu*'
        ];
        await sendMessage(phoneNumber, errorMessages[Math.floor(Math.random() * errorMessages.length)]);
        session.reset();
    }
}

// ===== ENVIAR MENSAGEM =====
async function sendMessage(to, text) {
    try {
        const response = await axios.post(
            `${WHATSAPP_API_URL}/${WHATSAPP_PHONE_ID}/messages`,
            {
                messaging_product: 'whatsapp',
                to: to,
                type: 'text',
                text: { body: text }
            },
            {
                headers: {
                    'Authorization': `Bearer ${WHATSAPP_TOKEN}`,
                    'Content-Type': 'application/json'
                }
            }
        );

        logger.info(`‚úÖ Mensagem enviada para ${to}`);
        return response.data;
    } catch (error) {
        logger.error('Erro ao enviar mensagem:', error.response?.data || error.message);
        throw error;
    }
}

// ===== ENVIAR LEMBRETE =====
async function sendReminder(phoneNumber, appointment) {
    const appointmentDate = new Date(appointment.scheduledDate + 'T' + appointment.scheduledTime);
    const now = new Date();
    const hoursUntil = Math.round((appointmentDate - now) / (1000 * 60 * 60));
    
    let timeText;
    if (hoursUntil <= 1) {
        timeText = 'j√° √© daqui a pouco';
    } else if (hoursUntil < 24) {
        timeText = `√© daqui a ${hoursUntil} hora${hoursUntil > 1 ? 's' : ''}`;
    } else {
        timeText = '√© amanh√£';
    }

    const reminderIntros = [
        `Oi! Passando aqui pra te lembrar... üòä`,
        `Opa! S√≥ lembrando voc√™... üëã`,
        `Oi, tudo bem? √â s√≥ um lembrete... üîî`
    ];

    const confirmationPrompts = [
        'Voc√™ vai conseguir vir?',
        'Vai dar pra voc√™ comparecer?',
        'T√° confirmado ainda?'
    ];

    const message = `${reminderIntros[Math.floor(Math.random() * reminderIntros.length)]}

Sua consulta ${timeText}! üìÖ

üë§ *${appointment.patient.name}*
üìÖ *${appointmentDate.toLocaleDateString('pt-BR')}* √†s *${appointment.scheduledTime}*
üë®‚Äç‚öïÔ∏è Com *${appointment.doctor?.name}*
üè• Na *${appointment.clinic?.name}*

${confirmationPrompts[Math.floor(Math.random() * confirmationPrompts.length)]} ü§î

1Ô∏è‚É£ *Sim! Vou comparecer* ‚úÖ
2Ô∏è‚É£ *Preciso remarcar* üìÖ`;

    await sendMessage(phoneNumber, message);
}

// ===== EXPORTAR =====
module.exports = {
    initialize,
    verifyWebhook,
    handleIncomingMessage,
    sendMessage,
    sendReminder
};

